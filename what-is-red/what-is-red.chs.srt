1
00:00:10,593 --> 00:00:14,410
我们的下一位演讲者是Nenad Rakocevic

2
00:00:14,410 --> 00:00:17,039
他给我们带来的是"什么是Red"

3
00:00:17,039 --> 00:00:22,496
(掌声)

4
00:00:22,886 --> 00:00:27,767
谢谢Greg. 同时感谢所有

5
00:00:27,767 --> 00:00:31,908
that donated to pay the cost for my trip
为我此次行程进行捐助
6
00:00:31,908 --> 00:00:33,728
so I could make it.
使我能够站在这里给大家做演示的人们。
7
00:00:33,728 --> 00:00:36,932
I've made a lot of Red presentations
我曾经做过很多关于Red的介绍
8
00:00:36,932 --> 00:00:43,013
but newcomers to Red are still coming to me
但是很多初次接触Red的人仍然跑来问我
9
00:00:43,013 --> 00:00:45,517
with this simple question:
这样一个简单的问题：
10
00:00:45,517 --> 00:00:47,400
just "What is Red"
究竟“什么是Red呢？”
11
00:00:47,400 --> 00:00:50,166
because the project has many aspects
因为这个项目涉及的范围非常广泛，
12
00:00:50,166 --> 00:00:51,741
and I can understand that.
这一点我可以理解。
13
00:00:51,741 --> 00:00:54,042
So I'll try in this presentation to give your
所以，我会尽量在这次介绍中给大家
14
00:00:54,042 --> 00:00:58,673
a good view of every part of the project.
做一个全面的展示。
15
00:00:58,673 --> 00:01:02,522
So let's start by an overview of the problem.
那么我们从问题的综述说起。
16
00:01:02,522 --> 00:01:06,517
It's not a picture of my brain cells.
这可不是一张大脑细胞的图片，
17
00:01:06,517 --> 00:01:10,566
It's a computer model of a global map
而是一个目前已知的宇宙的
18
00:01:10,566 --> 00:01:12,772
of the known Universe.
计算机模型图。
19
00:01:12,772 --> 00:01:14,740
That gives you a good picture
这可以让大家对这个问题涉及的范围之广
20
00:01:14,740 --> 00:01:18,230
of the size of the problem (laughter)
有一个直观的印象（笑声）
21
00:01:18,230 --> 00:01:20,329
And actually it's a hint at
这实际上也为
22
00:01:20,329 --> 00:01:23,036
what I was supposed to become
我原本是打算做什么的提供了线索。
23
00:01:23,036 --> 00:01:26,011
because I was studying astrophysics
因为我以前学的是天体物理学
24
00:01:26,011 --> 00:01:30,570
and I switched in college to Computer Science.
后来才转到了计算机科学专业。
25
00:01:30,570 --> 00:01:34,589
My view of the computing world is that
我对于计算机世界的认识是
26
00:01:34,589 --> 00:01:38,792
even today we are still using some primitive
即便是到了今天，我们还在用着一些非常原始的
27
00:01:38,792 --> 00:01:41,018
tools and techniques.
工具和技术。
28
00:01:41,018 --> 00:01:44,653
So we are not very far from these two guys
所以在软件领域我们其实与这两个人
29
00:01:44,653 --> 00:01:46,357
on the software side.
没太多差别。
30
00:01:46,357 --> 00:01:49,283
We are still doing it in a very primitive way
我们仍然在使用一种非常原始的方法做软件开发，
31
00:01:49,283 --> 00:01:51,928
because we keep reinventing the wheels
因为我们不断地重复发明轮子
32
00:01:51,928 --> 00:01:54,513
and constantly are doing the same mistakes
和犯相同的错误，
33
00:01:54,513 --> 00:01:56,041
again and again.
一次又一次。
34
00:01:56,041 --> 00:01:58,892
So AI will be laughing.
相信连机器人见了都会发笑。
35
00:01:58,902 --> 00:02:02,541
At least I hope. :-) (laughter)
至少我希望如此 :-) （笑声）
36
00:02:02,541 --> 00:02:08,308
So if we get back a bit more on the topic
现在回到正题上来
37
00:02:08,308 --> 00:02:12,563
there are actually a lot of programming languages
实际上，世界上已经有相当多的编程语言了
38
00:02:12,563 --> 00:02:14,927
If you look at the Wikipedia list
这是维基百科上的编程语言列表
39
00:02:14,927 --> 00:02:18,596
of programming languages, this is just the A part
以A开头的部分
40
00:02:18,596 --> 00:02:23,107
and that page is not even exhaustive.
甚至就连这部分一页都没能放得下。
41
00:02:23,107 --> 00:02:24,802
So there are literally thousands
所以说编程语言有成千上万
42
00:02:24,802 --> 00:02:27,188
of programming languages.
一点都不夸张。
43
00:02:27,188 --> 00:02:29,588
If you look there you will see some languages
在这里你会发现有一些语言
44
00:02:29,588 --> 00:02:32,839
that were created on the Amiga.
是在Amiga发明的
45
00:02:32,839 --> 00:02:34,465
The famous "Amiga E"
这是著名的"Amiga E"语言，
46
00:02:34,465 --> 00:02:37,288
and AMOS which made by a French guy...
AMOS语言是一个非常聪明的法国人发明的，
47
00:02:37,288 --> 00:02:42,988
a very bright guy, whose name is François Lionet.
他就是François Lionet。
48
00:02:42,988 --> 00:02:46,500
This Basic was featuring a DSL.
AMOS BASIC可以看做是一种领域特定语言（DSL）
49
00:02:46,500 --> 00:02:50,240
It was a tool I used to have
我曾在20多年前
50
00:02:50,240 --> 00:02:52,899
more than 20 years ago.
使用过它。
51
00:02:52,899 --> 00:02:56,445
The DSL was meant for animations...
这种领域编程语言(DSL)的用途是制作电影动画...
52
00:02:56,445 --> 00:03:00,268
...it was compiled to native code.
...它可以编译成本地代码。
53
00:03:00,268 --> 00:03:04,439
And the whole interpreter and compiler and IDE
AMOS整套的解释器、编译器和集成开发环境
54
00:03:04,439 --> 00:03:10,624
for AMOS was fully written in assembler.
都是用汇编语言编写的。
55
00:03:10,624 --> 00:03:15,262
So this guy was quite an inspiration for me.
这位仁兄给了我相当大的启发。
56
00:03:15,262 --> 00:03:19,448
Despite so many programming languages
尽管已经有了这么多的编程语言
57
00:03:19,448 --> 00:03:22,985
and tools we are still searching for a newer,
和工具，但我们还是在不断寻找更新、
58
00:03:22,985 --> 00:03:25,197
better solution.
更好的方法。
59
00:03:25,197 --> 00:03:28,035
The problems we are facing every day
软件领域经常遇到的问题
60
00:03:28,035 --> 00:03:31,225
in the software world are quite known now
都已经是老生常谈了。
61
00:03:31,225 --> 00:03:34,345
but we keep hitting them.
但是我们仍然在不断地与之相遇。
62
00:03:34,345 --> 00:03:37,582
Like exploding complexity... bloatware...
比如日益增加的软件复杂度...软件膨胀...
63
00:03:37,582 --> 00:03:40,334
No I don't mean Java, of course. (laughter)
当然我说的不是Java(笑声)
64
00:03:40,334 --> 00:03:42,225
Not thinking about Java. :-P
不要联想到Java :-P
65
00:03:42,225 --> 00:03:44,769
Slow performance... Black boxes, which can be
再比如运行效率差...以及黑盒子，
66
00:03:44,769 --> 00:03:46,554
closed source software, for example.
这一点可以以闭源软件为代表，
67
00:03:46,554 --> 00:03:49,598
Which is often a big problem when trying
当你遇到的bug超出了你所能掌控的范围时，
68
00:03:49,598 --> 00:03:53,461
to solve bugs that you can't reach.
这通常会是一个大问题。
69
00:03:53,461 --> 00:03:57,872
So instead of spending our time hitting these walls
所以与其花费时间在这些问题上碰壁，
70
00:03:57,872 --> 00:04:00,348
we should have fun doing programming
不如把编程变成一件快乐的事情。
71
00:04:00,348 --> 00:04:02,665
because programming is about having fun.
因为编程本来就应该是充满乐趣的一件事情。
72
00:04:02,665 --> 00:04:05,265
And this is the spirit we should have when
这是我们在使用计算机进行工作时
73
00:04:05,265 --> 00:04:07,852
we are facing our computer and working on it.
应该有的精神状态。
74
00:04:07,852 --> 00:04:11,400
It's like in those times where programming
就像在那些编程*仅仅*代表一种乐趣
75
00:04:11,400 --> 00:04:13,440
was *only* fun.
的年代一样。
76
00:04:13,440 --> 00:04:16,441
Since then, since the 80's
从那时起，即上个世纪八十年代，
77
00:04:16,441 --> 00:04:19,490
a lot of revolutions happened.
发生了很多技术变革。
78
00:04:19,490 --> 00:04:21,716
And currently we have two -- I think --
现今，我认为在计算机技术领域
79
00:04:21,716 --> 00:04:25,710
very important changes in the computing world.
有两个非常重要的变化
80
00:04:25,710 --> 00:04:28,281
The first one is augmenting the power
第一个是计算机的计算能力增强的途径
81
00:04:28,281 --> 00:04:31,224
of computers by adding new cores
由提升CPU的频率
82
00:04:31,224 --> 00:04:34,934
instead of raising the frequency of the CPUs.
开始转变为增加CPU核数。
83
00:04:34,934 --> 00:04:39,320
This has deep implications for programming tools.
这个变化会对编程工具产生深远影响。
84
00:04:39,320 --> 00:04:44,062
The other main revolution is that we are all now
另一个重要的变化是，市场的重心正在逐渐
85
00:04:44,062 --> 00:04:46,772
switching to mobile devices.
向移动端转移。
86
00:04:46,772 --> 00:04:49,987
The market is changing very fast.
市场在飞速发展，
87
00:04:49,987 --> 00:04:52,947
So the programming tools also need to adapt.
编程工具也应该顺应潮流而变。
88
00:04:52,947 --> 00:04:56,540
Despite those changes,
然而尽管发生了这些变革，
89
00:04:56,540 --> 00:04:59,593
we are still using very old tools, in fact.
实际情况是，我们仍然在使用一些非常古老的工具。
90
00:04:59,593 --> 00:05:03,677
So I took just the five most popular
我仅就五个最流行的语言来说一说这个问题
91
00:05:03,677 --> 00:05:07,004
programming languages from the Tiobe index...
这些语言摘自著名的
92
00:05:07,004 --> 00:05:09,111
...the famous index.
Tiobe编程语言排行榜。
93
00:05:09,111 --> 00:05:12,114
Yeah, C is still the main one
是的，C语言仍然是最重要的一门语言，
94
00:05:12,114 --> 00:05:14,672
and it's been around for almost 40 years now.
迄今为止它已经被广泛使用了将近40年。
95
00:05:14,672 --> 00:05:18,748
That's quite a long time in computing!
在计算机世界里，这可是一段相当长的时间！
96
00:05:18,748 --> 00:05:22,984
And C is absolutely not meant to address
很显然C语言绝对不是为了解决
97
00:05:22,984 --> 00:05:25,417
the modern needs for computing.
现代的计算需求而被发明出来的。
98
00:05:25,417 --> 00:05:27,973
And if you look at the other ones
如果你再看看其他语言
99
00:05:27,973 --> 00:05:30,784
that's almost more or less the same thing.
也都大同小异。
100
00:05:30,784 --> 00:05:33,205
Fortunately for us, some people...
所幸的是，有这么一些人...
101
00:05:33,205 --> 00:05:36,211
...some very rare people were aware of this
...一些非凡之士意识到了这个问题，
102
00:05:36,211 --> 00:05:41,981
and capable of giving an answer to these issues.
并且给出了问题的答案。
103
00:05:41,981 --> 00:05:45,129
People like Carl (gestures to Carl Sassenrath)
比如Carl（向Carl示意）
104
00:05:45,129 --> 00:05:47,309
who invented Rebol... fantastic tool.
他发明了Rebol...这门了不起的编程语言，
105
00:05:47,309 --> 00:05:50,383
Probably one of the greatest inventions
可以说是过去20年中编程领域
106
00:05:50,383 --> 00:05:55,080
in the programming world in the last 20 years.
最伟大的发明之一。
107
00:05:55,080 --> 00:05:57,875
So Rebol was a good solution, or a very
在很多领域，Rebol都表现不错，
108
00:05:57,875 --> 00:06:00,598
good solution for a lot of concerns.
或者说非常棒。
109
00:06:00,598 --> 00:06:01,978
*But not all.*
*但是，并不是全部领域*
110
00:06:01,978 --> 00:06:05,352
Something I would like to show to Carl...
我想向Carl展示一些东西...
111
00:06:05,352 --> 00:06:08,556
...maybe he hasn't seen it?
...或许他还没有见过？
112
00:06:08,556 --> 00:06:12,917
The wonders Rebol was doing, until recently,
直到最近，Rebol取得的最好成就，
113
00:06:12,917 --> 00:06:17,277
was just the Rebol community praising it
只是Rebol社区的人们在称赞它
114
00:06:17,277 --> 00:06:20,004
and trying to explain to people how Rebol
并努力向他人解释Rebol是一门多么
115
00:06:20,004 --> 00:06:23,947
was a productive tool, and expressive.
高效，表达能力多么强的编程语言。
116
00:06:23,947 --> 00:06:28,282
But recently a scientific study tried to measure
近期有一项科学研究试图衡量
117
00:06:28,282 --> 00:06:32,133
the expressiveness of programming languages.
各门语言的表达能力。
118
00:06:32,133 --> 00:06:37,597
So they did it. And Rebol... *surprise*! Is number 3.
这是他们的研究结果。令人吃惊的是，Rebol居然排名第3。
119
00:06:37,597 --> 00:06:41,516
In fact: number 1 and number 2 are DSLs.
实际情况是，排名第一和第二位的是两门领域特定语言（DSL）
120
00:06:41,516 --> 00:06:44,526
So guess who's the first one? (laughter)
猜猜是谁排名第一？（笑声）
121
00:06:44,526 --> 00:06:49,040
So that just confirms something we all knew
其实这不过是验证了我们
122
00:06:49,040 --> 00:06:51,141
since the beginning.
早就知道的事情：
123
00:06:51,141 --> 00:06:53,307
Rebol is a very productive tool
Rebol是一门生产效率极高的语言，
124
00:06:53,307 --> 00:06:55,935
and that's now proven. (laughter)
只不过现在有了明证。（笑声）
125
00:06:55,935 --> 00:07:00,715
But Red tries to go beyond what Rebol provides.
但是Red想要做的是超越Rebol。
126
00:07:00,715 --> 00:07:03,002
Mainly in terms of implementation
主要是在实现方式方面
127
00:07:03,002 --> 00:07:06,519
not in terms of language semantics or syntax.
而不是语法或语义方面。
128
00:07:06,519 --> 00:07:10,458
But more in terms of toolchain, implementations,
更多的是在工具链、实现方式
129
00:07:10,458 --> 00:07:13,065
and spreading.
和延伸方面。
130
00:07:13,065 --> 00:07:16,160
So what is Red, really?
那么究竟什么是Red呢？
131
00:07:16,160 --> 00:07:17,653
Red is what I call
Red是一门我称之为
132
00:07:17,653 --> 00:07:19,212
a *Full-Stack Programming Language*
*全栈式编程语言*的语言。
133
00:07:19,212 --> 00:07:22,317
Maybe you've heard about full-stack developers?
或许大家都听说过全栈工程师吧？
134
00:07:22,317 --> 00:07:25,796
So this one is a full-stack programming language.
现在又来了一门全栈式编程语言。
135
00:07:25,796 --> 00:07:28,995
And probably it's main characteristic
从某种意义上说它的主要特色是
136
00:07:28,995 --> 00:07:31,188
is that it's a true general purpose
这是一门真正意义上的
137
00:07:31,188 --> 00:07:33,287
programming solution.
通用编程语言。
138
00:07:33,287 --> 00:07:35,182
There are many languages
有相当多的编程语言
139
00:07:35,182 --> 00:07:39,288
that *advertise* as general purpose...
将自己*标榜*为通用编程语言...
140
00:07:39,288 --> 00:07:43,358
...but they are not as broad as Red can be.
...但是它们触及的范围都没有Red语言来的广泛。
141
00:07:43,358 --> 00:07:47,121
The other great characteristic about Red
Red语言的另一个特色是
142
00:07:47,121 --> 00:07:49,413
is that it's a stand-alone toolchain
它只有一个独立的工具链
143
00:07:49,413 --> 00:07:52,050
so we are not depending on the standard
这样的话我们就可以不依赖
144
00:07:52,050 --> 00:07:56,488
classic C toolchain, we have our own one.
经典的C语言工具链这样的标配了，我们有自己的工具链。
145
00:07:56,488 --> 00:07:59,648
Another important aspect of Red
Red的再一个重要方面是
146
00:07:59,648 --> 00:08:01,421
is it's about *freedom*.
它是*自由*的。
147
00:08:01,421 --> 00:08:03,695
Since the beginning my motivation for Red
由于我开发Red语言的初始动机是
148
00:08:03,695 --> 00:08:07,334
was to get free of any kind of restrictions
突破各种限制
149
00:08:07,334 --> 00:08:08,995
or any kind of limits.
或者限度，
150
00:08:08,995 --> 00:08:14,230
I want users of Red to feel the same.
我希望使用Red的人们也有相同的感受。
151
00:08:14,230 --> 00:08:18,165
So Red is simple to use, *thanks to Rebol*...
Red的简单易用*受益于Rebol*...
152
00:08:18,165 --> 00:08:23,770
...but Red has no arbitrary restrictions.
...但是Red不存在任何局限性。
153
00:08:23,770 --> 00:08:26,374
We try to address every possible need
我们着眼于方方面面的需求
154
00:08:26,374 --> 00:08:28,138
and every possible aspect so it
这样它就可以
155
00:08:28,138 --> 00:08:33,154
can be deployed, ported to any platform we need.
被部署、移植到任何我们想要的平台。
156
00:08:33,154 --> 00:08:35,799
Also, something very important in programming:
另外，在编程中非常重要的一点：
157
00:08:35,799 --> 00:08:39,061
you need to be feeling in control of your tool.
对自己所使用的工具要有掌控感。
158
00:08:39,061 --> 00:08:42,836
Often you use some tools that can be powerful
你会经常用到一些非常强大
159
00:08:42,836 --> 00:08:44,878
but you don't control them, because
但是不能自由掌控的工具，因为
160
00:08:44,878 --> 00:08:47,250
you don't understand what's happening inside.
你不了解它的内部是怎么运行的。
161
00:08:47,250 --> 00:08:48,730
Often because they are black boxes.
当然也通常因为它们是黑盒子。
162
00:08:48,730 --> 00:08:52,495
Or because they are sitting on a big pile of layers
或者是它们位于软件的一大堆层级当中
163
00:08:52,495 --> 00:08:56,225
of software so you can't just understand
以至于你不能了解
164
00:08:56,225 --> 00:08:57,921
what is happening inside.
内部究竟是怎么运行的。
165
00:08:57,921 --> 00:09:02,394
And an important last thing :-)
还有最后一点，非常重要的一点 :-)
166
00:09:02,394 --> 00:09:04,521
is the *Fun*. Yeah, we want the fun back.
就是*快乐*。是的，我们想要找回编程的快乐。
167
00:09:04,521 --> 00:09:08,808
Some people that tried to use Red
一些用过Red
168
00:09:08,808 --> 00:09:11,465
or Red/System, after compiling and running
或者Red/System的朋友在成功编译和运行
169
00:09:11,465 --> 00:09:14,262
their first program successfully
他们的第一个程序之后
170
00:09:14,262 --> 00:09:16,175
came back to me and said:
跑来告诉我说：
171
00:09:16,175 --> 00:09:17,367
"It's great because, it's fun."
“非常好玩，棒极了！”
172
00:09:17,367 --> 00:09:21,281
"I just tried it, and it worked, and it was great."
“我只是试了一下，居然运行起来了，太棒了。”
173
00:09:21,281 --> 00:09:25,132
People get that feeling -- what I was talking about
人们找到了那种我之前所说的
174
00:09:25,132 --> 00:09:27,620
That feeling from the 80's.
来自于上个世纪80年代的感觉，
175
00:09:27,620 --> 00:09:29,347
Where you feel really in control
那种你真的可以对你的编程工具
176
00:09:29,347 --> 00:09:31,121
of your programming tool.
完全掌控的感觉。
177
00:09:31,121 --> 00:09:34,387
So I'll try to explain what I mean by
接下来我会说一说我所说的
178
00:09:34,387 --> 00:09:36,782
"Full-Stack Programming Language" and
“全栈式编程语言”与
179
00:09:36,782 --> 00:09:40,455
"True General-Purpose Programming Language".
“真正意义上的通用编程语言”是什么。
180
00:09:40,455 --> 00:09:42,096
So I made this chart:
我画了这张图：
181
00:09:42,096 --> 00:09:43,414
"Domain Scope of Application"
部分主流编程语言的
182
00:09:43,414 --> 00:09:46,570
for a few of the main programming languages.
“领域适用范围图”。
183
00:09:46,570 --> 00:09:49,393
For example, assembler is drivers
例如，汇编语言用来编写驱动程序，
184
00:09:49,393 --> 00:09:52,019
and very low-level code.
属于非常低级的代码。
185
00:09:52,019 --> 00:09:54,895
You can see that Java is really limited in its
可以看到Java的能力局限于
186
00:09:54,895 --> 00:09:58,084
ability to address different abstraction levels.
解决各种抽象层的问题。
187
00:09:58,084 --> 00:10:00,607
Ruby is quite wide;
Ruby的适用范围很广;
188
00:10:00,607 --> 00:10:02,989
maybe it doesn't go down to the OS?
但还没有低到操作系统层级吧？
189
00:10:02,989 --> 00:10:05,598
I don't know if the Ruby interface
我不知道通过Ruby接口来
190
00:10:05,598 --> 00:10:09,888
for calling OS API is really good or not.
调用操作系统API是好还是坏。
191
00:10:09,888 --> 00:10:13,324
Rebol has quite a wide scope.
Rebol的适用范围相当广泛。
192
00:10:13,324 --> 00:10:16,880
Rascal is a very specific programming language.
Rascal是一种非常特别的编程语言，
193
00:10:16,880 --> 00:10:19,540
It's a kind of DSL,
它实际上是一种领域特定语言（DSL），
194
00:10:19,540 --> 00:10:23,246
which is meant for writing other DSLs.
用来编写别的领域特定语言（DSL）。
195
00:10:23,246 --> 00:10:26,522
So it's standing at the meta-DSL level.
因此它的适用范围在meta-DSL层。
196
00:10:26,522 --> 00:10:30,356
So where is Red on that scale?
那么Red的适用范围呢？
197
00:10:30,356 --> 00:10:33,954
Well Red is aiming at addresing all needs
Red的目标是满足所有这些需求，
198
00:10:33,954 --> 00:10:37,272
from the bottom to the top.
从底层到顶层，
199
00:10:37,272 --> 00:10:40,596
Because I don't want to have to rely on another tool.
因为我不想依赖另外一种工具。
200
00:10:40,596 --> 00:10:43,056
I want the Red programming language
我想让Red语言
201
00:10:43,056 --> 00:10:45,913
to be able to address all the needs
不依赖别的任何东西
202
00:10:45,913 --> 00:10:48,272
without relying on something else.
就能满足所有这些需求。
203
00:10:48,272 --> 00:10:51,236
So you will tell me that it's quite impossible
有人会说
204
00:10:51,236 --> 00:10:53,307
to make a language that addresses
发明一门适用范围如此之广的语言
205
00:10:53,307 --> 00:10:56,058
such a wide scope.
是不可能的。
206
00:10:56,058 --> 00:10:58,201
And you'll be right.
他很可能是对的。
207
00:10:58,201 --> 00:11:00,771
But Red has a trump card.
但是Red不一样，它有自己的王牌。
208
00:11:00,771 --> 00:11:04,418
Red/System covers the low layers
Red/System语言会负责较低的层级，
209
00:11:04,418 --> 00:11:06,604
and Red covers the upper layers.
Red语言则负责较高的层级。
210
00:11:06,604 --> 00:11:10,037
They are integrated together
二者可以相互协作，
211
00:11:10,037 --> 00:11:11,702
and working together.
配合无间。
212
00:11:11,702 --> 00:11:15,114
So Red/System, in fact, is a dialect of Red.
Red/System实际上是Red的一种方言。
213
00:11:15,114 --> 00:11:17,191
You can use it separately
既可以单独使用，
214
00:11:17,191 --> 00:11:20,112
or directly embedded totally in Red.
也可以直接嵌入在Red代码中使用。
215
00:11:20,112 --> 00:11:25,446
So let's have a look at the platforms we support.
下面再看一看所支持的系统平台。
216
00:11:25,446 --> 00:11:26,597
First on the desktop,
首先是桌面系统，
217
00:11:26,597 --> 00:11:30,755
we support the classic 3 main players.
我们支持三大主流操作系统。
218
00:11:30,755 --> 00:11:34,424
We also support some additional
同时也支持其他一些操作系统
219
00:11:34,424 --> 00:11:36,693
operating systems like Syllable.
比如Syllable。
220
00:11:36,693 --> 00:11:38,829
We would like to support FreeBSD
我们希望能够支持FreeBSD,
221
00:11:38,829 --> 00:11:41,350
but we had some low-level issues
但是由于遇到了一些底层的问题
222
00:11:41,350 --> 00:11:45,053
and no FreeBSD experts among us
同时缺少FreeBSD专家
223
00:11:45,053 --> 00:11:48,456
to solve those, so for now it's a bit stalled.
来解决这些问题，因此目前暂时被搁置了。
224
00:11:48,456 --> 00:11:52,454
But we could probably get Red ported
但如果可能的话，我们会尽快将Red移植到
225
00:11:52,454 --> 00:11:54,855
on FreeBSD rapidly.
FreeBSD上。
226
00:11:54,855 --> 00:11:57,687
Then we also want to address
我们也要支持
227
00:11:57,687 --> 00:12:00,774
the embedded market, starting with Android.
嵌入式平台市场，是从Android开始着手的，
228
00:12:00,774 --> 00:12:02,771
which we already support.
目前已经可以支持Android了。
229
00:12:02,771 --> 00:12:04,787
The next one will be iOS.
下一个将会是iOS。
230
00:12:04,787 --> 00:12:07,905
And we already run on Raspberry Pi
Red目前已经可以运行在
231
00:12:07,905 --> 00:12:10,367
which is becoming quite popular.
日渐流行的Raspberry Pi了。
232
00:12:10,367 --> 00:12:14,720
I guess Bo will do some demonstrations
我猜Bo可能会在明天给大家
233
00:12:14,720 --> 00:12:17,929
maybe tomorrow.
做一些演示。
234
00:12:17,929 --> 00:12:22,868
We also have an experimental port on Arduino
我们还有一个Arduino上的实验性质的移植版本
235
00:12:22,868 --> 00:12:27,030
We started with AVR 8-bit.
是为8位的AVR做的。
236
00:12:27,030 --> 00:12:30,044
But it's an experiment for now
当然目前只是实验性质的，
237
00:12:30,044 --> 00:12:32,895
because other boards are coming
因为不久其他一些电路板上的版本就会出现，
238
00:12:32,895 --> 00:12:36,014
like 32-bit boards or Raspberry Pi.
像是32位的或者Raspberry Pi，
239
00:12:36,014 --> 00:12:41,790
So 8-bit support may not be the thing to do now.
所以8位的并不是当务之急。
240
00:12:41,790 --> 00:12:45,320
We also want to support virtual machines.
我们还会支持虚拟机。
241
00:12:45,320 --> 00:12:49,753
We want to be able to connect to .NET
我们想要连通.NET平台
242
00:12:49,753 --> 00:12:53,139
to the JVM, and to JavaScript.
JVM平台以及Javascript平台。
243
00:12:53,139 --> 00:12:55,602
There are basically two methods
实现这一点
244
00:12:55,602 --> 00:12:56,467
to achieve this.
一般有两种方法。
245
00:12:56,467 --> 00:13:00,940
We can have a bridge, keeping Red like it is now
一种方法是使用桥接器，保持Red原样不动
246
00:13:00,940 --> 00:13:06,438
and bridging with these virtual machines.
使用桥接的方式来访问这些虚拟机。
247
00:13:06,438 --> 00:13:08,746
Or we can develop a new backend
另一种方法是为Red和Red/System
248
00:13:08,746 --> 00:13:11,146
for Red and Red/System
开发新的后端
249
00:13:11,146 --> 00:13:13,710
to be able to compile directly to the bytecode
使之能够直接编译成这些虚拟机的
250
00:13:13,710 --> 00:13:15,817
of these virtual machines.
字节码。
251
00:13:15,817 --> 00:13:17,905
So we have those two options.
所以这样我们有两种选择。
252
00:13:17,905 --> 00:13:21,645
We started by making some bridges for the JVM.
我们是从为JVM创建桥接器开始着手的。
253
00:13:21,645 --> 00:13:26,405
We'll try to choose each time
我们会为不同的虚拟机选择
254
00:13:26,405 --> 00:13:30,067
the right solution -- the best one for the job.
最适合的方案。
255
00:13:30,067 --> 00:13:33,188
So right now we are bridging with the JVM.
所以现在是采用桥接的方式连接JVM虚拟机。
256
00:13:33,188 --> 00:13:37,997
But we will probably compile for JavaScript directly.
但对于JavaScript可能会采用直接编译的方式。
257
00:13:37,997 --> 00:13:41,551
We have asm.js now, so we have
现在我们已经有了asm.js，这样我们就有了
258
00:13:41,551 --> 00:13:45,325
a really interesting platform to support.
一个相当吸引人的平台来支持。
259
00:13:45,325 --> 00:13:47,584
I expect Red and Red/System
我相信Red和Red/System能够
260
00:13:47,584 --> 00:13:50,755
to run quite fast on that.
在这上面运行很快。
261
00:13:50,755 --> 00:13:53,753
More practically, just another view of how it works
Red工作机制中更加务实的一面是，
262
00:13:53,753 --> 00:13:57,242
So you have Red: one binary.
只需要一个可执行文件，
263
00:13:57,242 --> 00:14:01,118
You download and get all these features.
将其下载下来，所有的特性就都具备了。
264
00:14:01,118 --> 00:14:04,756
You can run a Red script directly from memory.
你可以直接从内存中执行Red脚本，
265
00:14:04,756 --> 00:14:08,124
You can compile it to an executable.
可以把它编译成一个可执行文件。
266
00:14:08,124 --> 00:14:12,805
You can cross-compile it...
还可以进行交叉编译...
267
00:14:12,805 --> 00:14:15,324
we'll get back to that feature.
稍后我们再详细说这个特性。
268
00:14:15,324 --> 00:14:19,071
You can also directly compile Red/System scripts,
你也可以直接编译Red/System脚本，
269
00:14:19,071 --> 00:14:22,291
if you don't want to use the Red layer
如果你不想使用Red
270
00:14:22,291 --> 00:14:26,063
but you want to code a low-level application.
而是想编写一个底层应用程序的话。
271
00:14:26,063 --> 00:14:29,955
And you can also now compile shared libraries
你还可以编译共享库
272
00:14:29,955 --> 00:14:32,948
that opens the door for spreading Red
这样就为Red的延伸打开了方便之门，
273
00:14:32,948 --> 00:14:36,582
by plugging it everywhere we can.
即可以将它以插件的形式安装到任何我们想要安装的地方。
274
00:14:36,582 --> 00:14:39,954
You can also launch Red in a console mode
你还可以启动Red的控制台模式
275
00:14:39,954 --> 00:14:42,206
so we have a Red console.
这样我们就拥有了一个Red控制台。
276
00:14:42,206 --> 00:14:45,499
So cross-compilation... Red is now able to cross-compile
关于交叉编译...其实现阶段就可以进行交叉编译，
277
00:14:45,499 --> 00:14:49,442
to other systems, from any system to another.
从任一系统编译其他任何一个系统所需要的文件。
278
00:14:49,442 --> 00:14:52,731
In fact it's able to compile from any platform
实际上它可以从任一运行着Rebol的平台
279
00:14:52,731 --> 00:14:56,113
where Rebol runs to any other platform.
编译出其他任何平台的可执行文件。
280
00:14:56,113 --> 00:15:00,808
To achieve that you don't need a HOWTO
做到这一点不需要一份HOWTO文档
281
00:15:00,808 --> 00:15:02,363
You don't need a tutorial.
也不需要一份教程
282
00:15:02,363 --> 00:15:04,788
You don't need to search on the Net for
更不需要去网络上进行搜索
283
00:15:04,788 --> 00:15:07,182
how to achieve it.
该怎么实现。
284
00:15:07,182 --> 00:15:10,293
You simply pass a "-t" command and the target ID
你只需要添加一个“-t”命令和相应的目标ID就可以了，
285
00:15:10,293 --> 00:15:11,777
and that is all.
就这些。
286
00:15:11,777 --> 00:15:16,750
A target ID is just an entry in a configuration file
目标ID只是配置文件中的一个条目，
287
00:15:16,750 --> 00:15:21,988
a simple Red dialect, where we just list
这个配置文件是一种Red的方言，在其中我们只是列出了
288
00:15:21,988 --> 00:15:26,132
some options for the target platform.
目标平台的一些可选项。
289
00:15:26,132 --> 00:15:31,110
So currently we have this list of about 8 targets
到目前为止，我们共支持8个目标平台
290
00:15:31,110 --> 00:15:33,602
So we can cross-compile from any one
这样我们可以在任一平台上交叉编译其他平台需要的文件，
291
00:15:33,602 --> 00:15:35,828
to any other, as long as Rebol
只要源平台上
292
00:15:35,828 --> 00:15:40,124
runs on the source platform.
运行着Rebol。
293
00:15:40,124 --> 00:15:41,557
So as you can see we are supporting mainly
可以看到我们目前主要支持
294
00:15:41,557 --> 00:15:45,594
x86 and ARM based platforms.
基于X86和ARM的平台。
295
00:15:45,594 --> 00:15:49,412
To get a bit deeper inside the toolchain
更深入看一看会发现我们的工具链
296
00:15:49,412 --> 00:15:51,796
we have several parts.
分为几个部分。
297
00:15:51,796 --> 00:15:54,506
We have the classical couple: compiler, linker.
有编译器和链接器这对经典组合。
298
00:15:54,506 --> 00:16:01,832
So the compiler layer is able to mainly address
编译器主要支持
299
00:16:01,832 --> 00:16:07,115
those two backends, x86 and ARM.
 x86和ARM这两种后端。
300
00:16:07,115 --> 00:16:11,919
But we plan to extend it to support ARMv7
但是我们打算对其进行扩展以支持ARMv7
301
00:16:11,919 --> 00:16:17,236
"thumb mode" and 64-bit platforms.
的Thumb模式和64位的平台。
302
00:16:17,236 --> 00:16:22,287
We also will add the virtual machine backends.
我们以后还会支持虚拟机后端，
303
00:16:22,287 --> 00:16:26,207
So JavaScript, JVM bytecode... Dex for Dalvik
例如Javascript、JVM字节码，Dex指的是Dalvik虚拟机的dex档案，
304
00:16:26,207 --> 00:16:30,153
as an alternative for JVM on Android platform.
是Android平台上的JVM，
305
00:16:30,153 --> 00:16:34,462
And MSIL stands for the bytecode name
MSIL指的是.NET平台上的
306
00:16:34,462 --> 00:16:37,043
for the .NET platform.
MSIL中间语言代码。
307
00:16:37,043 --> 00:16:39,737
So the Linker is supporting the main file formats.
这样的话链接器就可以支持所有主流的文件格式了。
308
00:16:39,737 --> 00:16:43,532
We will extend it to also support static libraries.
我们后面将会对它进行扩展使其能够支持静态链接库。
309
00:16:43,532 --> 00:16:46,418
So you'll be able to compile a Red program
那时你就可以把Red程序编译成
310
00:16:46,418 --> 00:16:51,578
as a static library so you can link it later
静态链接库，之后与其他外部工具链——
311
00:16:51,578 --> 00:16:55,233
with another external toolchain, like a C one.
比如使用C语言编译的——进行链接。
312
00:16:55,233 --> 00:16:59,655
That's an alternative way to spread Red
这是另外一条延伸Red语言的途径，
313
00:16:59,655 --> 00:17:02,448
and to enable people to use Red
允许它
314
00:17:02,448 --> 00:17:04,962
in third-party toolchain languages/applications.
和第三方语言或应用程序构成的工具链一起使用。
315
00:17:04,962 --> 00:17:09,242
And we also go down to the kernel level
我们甚至深入到了内核层级
316
00:17:09,242 --> 00:17:14,305
and we will provide support for building
这样就可以直接使用Red语言
317
00:17:14,305 --> 00:17:19,234
kernel drivers, or even full operating systems
开发内核驱动程序，
318
00:17:19,234 --> 00:17:21,787
directly from Red.
甚至是完整的操作系统。
319
00:17:21,787 --> 00:17:24,199
And currently we have experimental
到目前为止已经可以支持Windows内核驱动程序的开发，
320
00:17:24,199 --> 00:17:27,504
Windows kernel driver support, already working.
虽然是实验性的，但是是可以使用的。
321
00:17:27,504 --> 00:17:31,980
If there are kernel driver developers here
如果在座的各位中有谁从事驱动程序开发
322
00:17:31,980 --> 00:17:34,213
you can have fun with it. :-P
可以享用一下。 :-P
323
00:17:34,213 --> 00:17:37,458
Last one: something that doesn't exist
最后一点，据我所知，
324
00:17:37,458 --> 00:17:40,247
as far as I know, in the classic C toolchain:
有一样东西在经典的C语言工具链中是没有的：
325
00:17:40,247 --> 00:17:42,530
we'll have a packager layer
我们将提供一个打包工具，
326
00:17:42,530 --> 00:17:46,044
which is not implemented yet, but will be soon.
这个目前还没有实现，但是很快就会有。
327
00:17:46,044 --> 00:17:51,589
We'll start with the Android APK backend.
我们最先从Android的APK后端做起。
328
00:17:51,589 --> 00:17:54,697
So the point of this layer
这个工具主要用来
329
00:17:54,697 --> 00:17:58,850
is just to take several files and package them
将一些文件打包
330
00:17:58,850 --> 00:18:03,445
and format them like the target platform expects.
生成目标平台所需要的格式文件。
331
00:18:03,445 --> 00:18:06,426
So we'll support Android, we'll support iOS.
我们会支持Android,也会支持iOS，
332
00:18:06,426 --> 00:18:08,997
But such a packager could also be used
其实这样一个打包器也可以用来
333
00:18:08,997 --> 00:18:13,409
for packaging web applications.
打包web应用。
334
00:18:13,409 --> 00:18:17,371
So like Java does for the .WAR format
就像Java中的.WAR包一样
335
00:18:17,371 --> 00:18:20,196
which has very interesting abilities
WAR包有提供了很多吸引人的功能，
336
00:18:20,196 --> 00:18:23,489
like simplifying the deployment of web applications
比如简化应用的部署过程，
337
00:18:23,489 --> 00:18:25,276
and being able to version them
进行版本管理，
338
00:18:25,276 --> 00:18:27,050
or roll back deployment
或者对部署进行回滚，
339
00:18:27,050 --> 00:18:29,342
which are great things to have.
这些都是相当有用的。
340
00:18:29,342 --> 00:18:31,027
Another aspect of the toolchain
关于工具链的另外一点说明是
341
00:18:31,027 --> 00:18:32,544
is that currently the toolchain
它目前处于自举阶段，
342
00:18:32,544 --> 00:18:36,774
is bootstrapped in Rebol 2.
代码是用Rebol 2开发的，
343
00:18:36,774 --> 00:18:40,686
We are already running on that for two years.
迄今为止已经这么做有两年了。
344
00:18:40,686 --> 00:18:46,907
But the final Red will have a JIT compiler.
不过最终形态的Red将会拥有一个JIT编译器，
345
00:18:46,907 --> 00:18:50,717
To have a JIT compiler we need to go self-hosted.
而实现JIT编译器需要实现自托管。
346
00:18:50,717 --> 00:18:54,347
So we need to have Red written in Red.
因此我们需要使用Red语言自身来重写Red。
347
00:18:54,347 --> 00:18:58,587
That's the only way to get a proper JIT compiler.
这是开发一个适合的JIT编译器的唯一途径。
348
00:18:58,587 --> 00:19:03,543
So we'll most probably work on that next year.
我们很可能会在下一年就做这些工作。
349
00:19:03,543 --> 00:19:07,550
I have a few slides about the Red language itself.
我做了很多介绍Red语言自身特性的幻灯片
350
00:19:07,550 --> 00:19:10,796
But I won't go into too many details
但是今天不会涉及太多细节的东西，
351
00:19:10,796 --> 00:19:13,394
because it will take too much time.
因为这需要很多时间。
352
00:19:13,394 --> 00:19:18,018
The first thing to understand about Red language
理解Red语言的第一个要点是
353
00:19:18,018 --> 00:19:21,098
is that it's very close to Rebol.
它非常接近Rebol语言。
354
00:19:21,098 --> 00:19:26,585
You have some of the main Rebol characteristics
它具有Rebol的主要的特征，
355
00:19:26,585 --> 00:19:31,588
like definitional scoping and dynamic binding.
比如definitional scoping和动态绑定。
356
00:19:31,588 --> 00:19:37,178
You also have the ability to program in Red
你在使用Red进行开发时可以
357
00:19:37,178 --> 00:19:40,106
using whatever paradigm you want.
选择你想使用的任何范式。
358
00:19:40,106 --> 00:19:43,031
So *"paradigm-neutral"* is an expression
我非常喜欢Gabriele (Santilli)所说的
359
00:19:43,031 --> 00:19:46,673
from Gabriele (Santilli) and I like it very much
“范式中立”这一表述，
360
00:19:46,673 --> 00:19:50,013
because it expresses really well this ability
它准确描述了
361
00:19:50,013 --> 00:19:53,878
to not be bound by a specific paradigm.
不局限于任何一种范式的能力。
362
00:19:55,318 --> 00:19:59,298
A difference between Red and Rebol
Red和Rebol之间的一个区别是
363
00:19:59,298 --> 00:20:05,376
is that in Red you can optionally type local variables
在Red中你可以选择性地指定函数中局部变量的类型，
364
00:20:05,376 --> 00:20:09,756
and you can also type the return value
同时还可以指定
365
00:20:09,756 --> 00:20:12,147
of functions.
返回值的类型。
366
00:20:12,147 --> 00:20:17,048
So in Rebol, it doesn't have much meaning
在Rebol中，这样做意义不大，
367
00:20:17,048 --> 00:20:25,102
because it's an interpreter, and it has no value.
因为它只是是个解释器，这样做没有必要。
368
00:20:25,102 --> 00:20:27,874
But for a compiler, it has great value.
但是对于编译器就不一样了，是非常有必要的。
369
00:20:27,874 --> 00:20:33,604
Because annotating those types in the function
因为在函数中指定这些数据的类型
370
00:20:33,604 --> 00:20:37,791
allows the compiler to generate
可以使编译器产生
371
00:20:37,791 --> 00:20:43,616
much more specialized, faster, and efficient code
比没有指定时更加明确、快速和
372
00:20:43,616 --> 00:20:46,818
than without the annotations.
高效率的代码。
373
00:20:47,728 --> 00:20:53,186
Red is "optionally typed". So you can type it or not.
在Red中数据类型是可以选择性地指定的。指定或者不指定都可以，
374
00:20:53,186 --> 00:20:56,989
It depends on your needs, or the way you program.
完全取决于你的需求或者编程的方式。
375
00:20:56,989 --> 00:20:59,333
So you can do it in the Rebol way
你可以选择类似于Rebol的方式编程，
376
00:20:59,333 --> 00:21:01,619
which will be very flexible.
这种方式非常灵活，
377
00:21:01,619 --> 00:21:06,168
But you will end up with slower performance.
缺点是性能较差。
378
00:21:06,168 --> 00:21:08,549
Or you can do it the static way
你也可以选择静态的方式，
379
00:21:08,549 --> 00:21:10,581
where you type everything
即为所有的一切都指定好类型，
380
00:21:10,581 --> 00:21:13,702
and the compiler will be able to do more type-checking
这样的话，编译器就会做更多的类型检查工作，
381
00:21:13,702 --> 00:21:16,969
so you will get some warnings or some errors
你就可以在编译阶段而不是运行阶段
382
00:21:16,969 --> 00:21:21,230
at compile-time instead of getting them at run-time.
获得警告或者错误提示。
383
00:21:21,230 --> 00:21:28,353
Also, if you are not using the type annotations
另外，如果你没有添加类型描述，
384
00:21:28,353 --> 00:21:31,687
the compiler will be able in some cases
在某些情况下，编译器可以
385
00:21:31,687 --> 00:21:34,141
to do some type inference.
做一定的类型推断工作，
386
00:21:34,141 --> 00:21:36,654
So it will be able to guess the types for you.
帮助你推测变量的类型。
387
00:21:36,654 --> 00:21:41,093
But as Red, like Rebol, is a very dynamic language
但是和Rebol一样，Red也是一门动态性很高的语言，
388
00:21:41,093 --> 00:21:48,734
the extent to which the inference engine
所以推测引擎的功能
389
00:21:48,734 --> 00:21:53,581
can guess those types is quite limited.
是非常有限的，
390
00:21:53,581 --> 00:21:56,756
So, it will be a little help, but not a big one.
因此它能够提供的帮助也是很有限的。
391
00:21:56,756 --> 00:22:01,167
We of course have Unicode support.
我们当然会支持Unicode。
392
00:22:01,167 --> 00:22:04,623
Red source code is UTF-8.
Red源代码的编码格式是UTF-8。
393
00:22:04,623 --> 00:22:09,567
We'll provide some external codecs for other encodings.
我们也会为其他编码格式提供一些外部的编解码器。
394
00:22:09,567 --> 00:22:16,728
Internally, basically, Red stores and manages
基本上，Red语言内部存储和操作
395
00:22:16,728 --> 00:22:20,036
Unicode strings like Python does
Unicode字符串的方式
396
00:22:20,036 --> 00:22:22,719
in the latest versions.
与最新版本的Python语言相似。
397
00:22:22,719 --> 00:22:29,671
So the internal storage is fixed size.
内部存储是定长的，
398
00:22:29,671 --> 00:22:35,382
But it can take from 1 byte to up to 4 bytes
但是每个不同的码点可能会占用
399
00:22:35,382 --> 00:22:37,921
per codepoint.
1到4个不等的字节。
400
00:22:37,921 --> 00:22:40,144
And the system will automatically adapt
系统会根据输入
401
00:22:40,144 --> 00:22:43,224
and adjust the size according to the input
和对字符串所做的修改
402
00:22:43,224 --> 00:22:48,908
and the modifications you are making on the string.
自动适应和调整所需要的长度。
403
00:22:48,908 --> 00:22:54,977
Another part that's very important in Red
Red的另外一个重要方面
404
00:22:54,977 --> 00:22:57,640
is the concurrency support.
是对并发的支持。
405
00:22:57,640 --> 00:23:00,108
But currently it's not implemented
但是由于目前尚未实现
406
00:23:00,108 --> 00:23:04,207
so I won't go in details about that.
所以我就不进行深入探讨了。
407
00:23:04,207 --> 00:23:09,102
We want to support two main things:
两项主要的事情：
408
00:23:09,102 --> 00:23:11,330
we want to support task parallelism
一是任务并行，
409
00:23:11,330 --> 00:23:15,331
so you can execute several threads of code
这样就可以在多核上
410
00:23:15,331 --> 00:23:18,367
in parallel using other multiple cores.
并行执行多个线程的代码。
411
00:23:18,367 --> 00:23:21,891
We'll probably use the Actor abstractions.
我们可能会采用Actor模型。
412
00:23:21,891 --> 00:23:26,693
But there are other abstractions
但是从Red项目开始以来
413
00:23:26,693 --> 00:23:31,042
that since the beginning of the Red project
我们考虑过众多其他的并发模型。
414
00:23:31,042 --> 00:23:34,926
are getting a lot of traction. Like Go routines,
比如Go routines，
415
00:23:34,926 --> 00:23:38,981
which are becoming a big selling point
这是Go语言的一个
416
00:23:38,981 --> 00:23:40,645
for the Go language.
相当大的卖点。
417
00:23:40,645 --> 00:23:43,082
So that's something we should consider
也许我们也应该为Red考虑一下，
418
00:23:43,082 --> 00:23:45,725
also for Red, maybe...
或许是...
419
00:23:45,725 --> 00:23:48,651
in addition or as a replacement for actors
作为actor及其他模型的补充，
420
00:23:48,651 --> 00:23:50,974
and other kinds of abstractions.
或许是将它们替代。
421
00:23:50,974 --> 00:23:54,765
So when we get to the point of implementing
因此当我们要着手实现
422
00:23:54,765 --> 00:23:57,311
the concurrency support we need to revise
并发支持的时候会重新考虑
423
00:23:57,311 --> 00:23:59,900
all the design choices and see
所有相关的设计决策，
424
00:23:59,900 --> 00:24:03,665
if we can update them by copying
看一看是否可以
425
00:24:03,665 --> 00:24:06,840
some other successful strategies.
复制其他的成功策略来完善它们。
426
00:24:06,840 --> 00:24:09,047
We also want to have some level of
我们还想通过使用单指令流多数据流（SIMD）
427
00:24:09,047 --> 00:24:13,712
data parallelism using either SIMD
或是多核处理技术来实现
428
00:24:13,712 --> 00:24:16,582
or multicore processing.
一定程度的数据并行。
429
00:24:16,582 --> 00:24:19,851
So basically that will be using the ability
主要会用到
430
00:24:19,851 --> 00:24:25,917
to parallelize processing of Red series.
Red系列值并行处理的功能。
431
00:24:25,917 --> 00:24:30,758
We would also like to address something
我们还打算解决一些
432
00:24:30,758 --> 00:24:33,476
that Rebol currently doesn't really address
目前Rebol尚未能真正解决的问题，
433
00:24:33,476 --> 00:24:36,231
which is: how do you make a dialect?
这就是：怎么实现一种方言，
434
00:24:36,231 --> 00:24:38,956
Or how do you make a DSL?
或是领域特定语言（DSL）？
435
00:24:38,956 --> 00:24:41,438
Rebol is great for that --
Rebol非常擅长于此
436
00:24:41,438 --> 00:24:44,368
it's probably one of the best tools for doing that
它可能是做这类事情的最好的工具之一
437
00:24:44,368 --> 00:24:45,658
because it has PARSE and because
因为它拥有PARSE以及
438
00:24:45,658 --> 00:24:48,084
it has some interesting qualities
其他一些令人惊艳的特征，
439
00:24:48,084 --> 00:24:50,101
that make it a good choice for that.
这些使得它成为一个不错的选择。
440
00:24:50,101 --> 00:24:54,911
Anyway building a DSL or building a dialect
然而创造一门领域特定语言或者方言
441
00:24:54,911 --> 00:24:57,186
is not something easy.
可不是一件那么容易的事情。
442
00:24:57,186 --> 00:24:59,774
Because you need to design it first.
因为你首先需要进行设计，
443
00:24:59,774 --> 00:25:01,425
That's already a lot of work.
这里面就有相当多的工作要做。
444
00:25:01,425 --> 00:25:03,427
And then you need to implement it.
然后你还要去将其实现。
445
00:25:03,427 --> 00:25:07,113
And implementing a DSL or a dialect
实现一种领域特定语言或者方言
446
00:25:07,113 --> 00:25:11,151
is implementing an interpreter or a compiler.
其实就是实现一个解释器或者编译器。
447
00:25:11,151 --> 00:25:17,524
For that you are almost left alone with the code.
到了这一步，你唯一拥有的就只是代码了。
448
00:25:17,524 --> 00:25:20,462
So you don't have really a framework
你并没有一个真正意义上的框架
449
00:25:20,462 --> 00:25:22,134
for doing that.
来辅助你做这些事情。
450
00:25:22,134 --> 00:25:25,585
And it's possible to leverage the qualities
一种可行的方案是
451
00:25:25,585 --> 00:25:27,439
of the Rebol language in Red
借助Rebol语言的力量
452
00:25:27,439 --> 00:25:29,507
or maybe even in Rebol
在Red或者Rebol中
453
00:25:29,507 --> 00:25:32,431
to make a kind of meta-DSL
创造一种用来设计DSL的DSL（meta-DSL），
454
00:25:32,431 --> 00:25:38,218
that will allow you to be much more productive
借助它可以使你的工作更加富有成效，
455
00:25:38,218 --> 00:25:40,920
and give you a framework
同时也提供了一个
456
00:25:40,920 --> 00:25:44,260
for building new dialects and new DSLs.
创建新的方言和领域特定语言（DSL）的框架。
457
00:25:44,260 --> 00:25:47,156
Basically it will be something like
总的说来它可以看做一个
458
00:25:47,156 --> 00:25:50,105
a higher-level version of PARSE.
更高级的PARSE。
459
00:25:50,105 --> 00:25:52,557
You can think about it, for example,
举个例子，可以这样设想它，
460
00:25:52,557 --> 00:25:59,457
like having PARSE with an event loop
在使用PARSE解析一个事件轮询时，
461
00:25:59,457 --> 00:26:03,732
and the event loop will be hidden.
这个事件轮询会被隐藏起来，
462
00:26:03,732 --> 00:26:07,914
Something like Visual Basic does.
就像Visual Basic做的那样。
463
00:26:07,914 --> 00:26:11,544
And you will just implement events
你只需要实现事件
464
00:26:11,544 --> 00:26:17,351
to create your DSL as an interpreter or compiler.
就可以创造你的领域特定语言了，不论是以解释器还是编译器的形式。
465
00:26:17,351 --> 00:26:26,170
So what does the Red compiler do?
Red的编译器用来做什么事情呢？
466
00:26:26,170 --> 00:26:30,786
The Red compiler converts Red code
它会把Red代码转换为
467
00:26:30,786 --> 00:26:34,944
into Red/System which is the lower-level layer.
低层级的Red/System代码。
468
00:26:34,944 --> 00:26:40,093
I just wanted to show you what it looks like.
下面我会给大家演示一下。
469
00:26:40,093 --> 00:26:45,535
So if we take a very simple Red expression
首先我们有一个非常简单的Red表达式，
470
00:26:45,535 --> 00:26:48,493
the Red compiler parses it
然后Red编译器会对其进行剖析，
471
00:26:48,493 --> 00:26:53,884
and uses a stack abstraction to place the arguments
并且使用一个堆栈（stack）结构来存放参数。
472
00:26:53,884 --> 00:26:58,480
In fact it uses two stacks: one for calls
实际上这里用到了两个堆栈：一个调用栈，
473
00:26:58,480 --> 00:27:01,819
and one for arguments.
一个数据栈。
474
00:27:01,819 --> 00:27:05,361
And then the emitter will produce Red/System code
之后代码生成器就会基于此
475
00:27:05,361 --> 00:27:08,363
based on that.
生成Red/System代码。
476
00:27:08,363 --> 00:27:10,782
So what you see on the right side
右边的部分就是
477
00:27:10,782 --> 00:27:14,350
is the Red/System output for that expression
那个表达式最终生成的Red/System代码，
478
00:27:14,350 --> 00:27:18,061
calling the Red runtime API.
称之为Red运行时API。
479
00:27:22,651 --> 00:27:28,334
Another singular aspect of the Red compiler
我认为Red编译器和Red语言
480
00:27:28,334 --> 00:27:29,406
and the Red language
另外一个非凡的方面是
481
00:27:29,406 --> 00:27:34,169
is that it combines several kinds of approaches
它把几种相当独特的方法
482
00:27:34,169 --> 00:27:37,846
which is something quite unique, I think.
结合在一起。
483
00:27:37,846 --> 00:27:41,156
So basically you have a static compiler.
最基本的是一个静态编译器。
484
00:27:41,156 --> 00:27:44,538
That static compiler will generate code
这个静态编译器会与一个内存的解释器
485
00:27:44,538 --> 00:27:46,584
with an interpreter inside, and tomorrow
一起生成编译后的代码，将来
486
00:27:46,584 --> 00:27:51,606
a JIT-compiler embedded inside your executable.
还会在可执行文件中内嵌一个JIT编译器。
487
00:27:51,606 --> 00:27:58,368
All these three parts will be able to work together
以上三部分会
488
00:27:58,368 --> 00:28:02,334
in a very collaborative way.
协同工作。
489
00:28:02,334 --> 00:28:05,191
So for example, the compiled code
比如，编译后的代码
490
00:28:05,191 --> 00:28:08,428
can call the internal interpreter
可以调用内部的解释器
491
00:28:08,428 --> 00:28:12,551
which itself can call back into the compiled code.
而解释器本身也可以反过来调用编译后的代码。
492
00:28:12,551 --> 00:28:16,189
Same thing for the JIT compiler.
JIT编译器也是一样。
493
00:28:16,189 --> 00:28:19,973
It's a bit abstract, but I can show you at the end
听起来有点抽象，但是在演示稿
494
00:28:19,973 --> 00:28:21,707
of the presentation a slide
的最后一张
495
00:28:21,707 --> 00:28:23,904
with a practical case for such an approach.
会有一个采用这种方法的实例。
496
00:28:23,904 --> 00:28:28,901
In fact, such an approach is a very powerful tool
其实，这是一种解决非常复杂的语义问题
497
00:28:28,901 --> 00:28:35,136
to solve very complex semantic cases.
的非常强大的方法。
498
00:28:35,136 --> 00:28:39,575
For example, compiling symbolic code,
例如，编译符号代码
499
00:28:39,575 --> 00:28:42,229
which is something quite difficult to achieve.
是一件非常困难的事情。
500
00:28:42,229 --> 00:28:43,740
But if you combine different approaches
但是如果结合不同的方法
501
00:28:43,740 --> 00:28:49,758
you can find a very efficient solution.
就会找到一个非常有效的方案。
502
00:28:49,758 --> 00:28:54,407
So this is just a very simple example
我用一个非常简单的示例
503
00:28:54,407 --> 00:29:00,583
of how Red code looks.
来演示一下Red代码长得什么样。
504
00:29:00,583 --> 00:29:03,399
You have the same principle like in Rebol
与Rebol一样，
505
00:29:03,399 --> 00:29:08,492
so you have a marker which is [Red]
最开始是一个由[Red]标识符及
506
00:29:08,492 --> 00:29:13,355
followed by a block that constitutes a header
后面紧跟着的文件头方块组成的标记，
507
00:29:13,355 --> 00:29:17,254
and your code goes after that.
之后是你的代码。
508
00:29:17,254 --> 00:29:19,921
Hello world is just [print "Hello World"]
Hello world只需要写[print "Hello World"]就可以了。
509
00:29:19,921 --> 00:29:22,312
like in Rebol, and the rest of the code
就像在Rebol中一样。其余的代码
510
00:29:22,312 --> 00:29:26,336
probably looks very much like Rebol
也看起来非常像Rebol代码，
511
00:29:26,336 --> 00:29:32,270
except maybe for the [return: [type!]]
有一点例外，就是[return: [type!]]，
512
00:29:32,270 --> 00:29:36,908
which is optional, but it's the kind of
这个是可选的，它属于我前面讲过的
513
00:29:36,908 --> 00:29:40,409
optional typing I was talking about just before.
可选的类型指定特征。
514
00:29:40,409 --> 00:29:43,389
So you have an example there.
现在你看到示例了。
515
00:29:43,389 --> 00:29:48,196
It's not mandatory to put it, but if you put it
这个并不是强制要求的，但是如果这么做了的话
516
00:29:48,196 --> 00:29:54,758
the compiler will generate better, faster code.
编译器就会生成更好更快的代码。
517
00:29:54,758 --> 00:29:59,006
So just a bit more detailed view
以上就是对Red语言的内部细节
518
00:29:59,006 --> 00:30:02,905
of the internals of Red, and the different parts
和不同的组成部分的介绍，
519
00:30:02,905 --> 00:30:05,640
so you get a better picture of how
你现在应该对它们的关联关系
520
00:30:05,640 --> 00:30:09,472
all those elements are related.
有了更清晰的认识。
521
00:30:09,472 --> 00:30:13,971
So if we start from the guy on the right
让我们从最右边的人说起。
522
00:30:13,971 --> 00:30:17,047
we have a command-line front-end script
这里有一个命令行脚本
523
00:30:17,047 --> 00:30:19,852
which is written currently in Rebol2
目前是用Rebol2写的，
524
00:30:19,852 --> 00:30:25,527
and behind it we have the two stacks
在它后面是两个堆栈，
525
00:30:25,527 --> 00:30:28,351
for the two compilers. One for Red, which is
分别属于两个编译器。一个是Red的，
526
00:30:28,351 --> 00:30:32,604
shorter because it just emits code for Red/System.
它比较简短，因为产生的是Red/System代码。
527
00:30:32,604 --> 00:30:34,311
And one for Red/System
另一个是Red/System的，
528
00:30:34,311 --> 00:30:36,720
which goes down to the packager
从上到下直到打包器，
529
00:30:36,720 --> 00:30:41,424
so it can emit and produce binary files.
它可以生成二进制文件。
530
00:30:41,424 --> 00:30:47,027
All that is the toolchain written in Rebol 2.
上面所说的是使用Rebol2写的工具链。
531
00:30:47,027 --> 00:30:52,304
On the left side, you have the Red runtime.
左边的是Red的运行时，
532
00:30:52,304 --> 00:30:55,586
Which is quite a big piece of code,
它的代码量很大，
533
00:30:55,586 --> 00:30:59,651
actually probably bigger than the other side.
甚至比整个右边的都大。
534
00:30:59,651 --> 00:31:02,964
And which is written in Red/System.
这是用Red/System写的。
535
00:31:02,964 --> 00:31:06,914
So you'll find all the real power on that side
“大腕”们都位于这一边。
536
00:31:06,914 --> 00:31:08,649
for example, all the datatypes,
例如，所有的数据类型，
537
00:31:08,649 --> 00:31:12,104
all the natives, the mezzanine code,
全部本地代码（natives），中间层代码，
538
00:31:12,104 --> 00:31:16,600
the interpreter, the bridges -- like the Java one
解释器，桥接器——像刚才提到的Java桥接器，
539
00:31:16,600 --> 00:31:19,025
which is already available.
目前已经为大家提供了。
540
00:31:19,025 --> 00:31:23,058
The memory manager and the low-level interfaces
内存管理器和用来访问底层部件
541
00:31:23,058 --> 00:31:26,485
to the underlying pieces.
的低层级接口。
542
00:31:26,485 --> 00:31:28,829
So for example you have the direct access
例如你不仅可以直接访问
543
00:31:28,829 --> 00:31:31,993
to the OS API but also to the kernel.
操作系统的API，而且还可以访问内核代码。
544
00:31:31,993 --> 00:31:34,001
On Linux you can do syscalls directly.
在Linux系统上可以直接进行系统调用。
545
00:31:34,001 --> 00:31:38,340
And if necessary you can go even down
如果需要的话，甚至可以深入到硬件层级，
546
00:31:38,340 --> 00:31:41,869
to the hardware and call very low-level features.
来调用非常低级的功能。
547
00:31:44,599 --> 00:31:46,625
Maybe I just missed the Red Console also
我可能忘了介绍Red的控制台
548
00:31:46,625 --> 00:31:49,985
which is also written in Red
它也是用Red语言写的，
549
00:31:49,985 --> 00:31:52,946
and Red/System for the low-level parts.
Red/System负责比较低级的部分
550
00:31:53,816 --> 00:31:57,120
About Red/System... I have a small presentation
说到Red/System...明天我还会有一个比较小的
551
00:31:57,120 --> 00:32:01,142
tomorrow specifically on Red/System, because
专门介绍Red/System的演示，因为
552
00:32:01,142 --> 00:32:06,082
it's kind of a new thing in Red compared to Rebol.
对比Rebol来说，这是Red中的一个新玩意。
553
00:32:06,082 --> 00:32:08,541
So I have just a slide about Red/System
所以我只准备了一张幻灯片来介绍Red/System，
554
00:32:08,541 --> 00:32:10,120
to give you just an overview.
大家有一个大概的印象就好了。
555
00:32:10,120 --> 00:32:16,748
So basically it's just a kind of C-level language
事实上，它是一种与C语言同一级别的语言
556
00:32:16,748 --> 00:32:20,078
but with a Red syntax.
却使用的是Red语言形式的语法。
557
00:32:20,078 --> 00:32:22,760
So it often feels like coding in Red
所以感觉像是在用Red语言编程
558
00:32:22,760 --> 00:32:29,827
but with very low-level datatypes and actions.
但是使用的是非常低级的数据类型和操作。
559
00:32:29,827 --> 00:32:32,630
So it's statically compiled.
它采用的是静态编译的方法。
560
00:32:32,630 --> 00:32:35,956
It's currently not optimized at all. :-)
到目前为止还没有进行任何优化。:-)
561
00:32:35,956 --> 00:32:40,988
But it's only 4x slower than optimized C
不过它只比经过“-O2”级别优化编译的C语言代码
562
00:32:40,988 --> 00:32:43,849
compiled with "-O2".
慢4倍。
563
00:32:43,849 --> 00:32:47,674
So it's quite good, actually it's very good.
因此它还是相当不错的，实际上是非常不错。
564
00:32:47,674 --> 00:32:51,224
Because once we add the optimization layers
因为一旦我们对其进行了优化，
565
00:32:51,224 --> 00:32:53,398
we'll be very, very close to C.
运行效率将会非常非常接近C语言。
566
00:32:53,398 --> 00:32:57,362
We probably won't beat it, but that's not the goal.
虽然不会超越C语言，那不是我们的目标，
567
00:32:57,362 --> 00:33:00,014
But we'll be very, very close.
但是会非常非常接近。
568
00:33:00,014 --> 00:33:05,041
So Red&#x2F;System will be a really viable alternative to C.
这样的话Red/System将会是C语言的一个非常可行的替代语言。
569
00:33:05,041 --> 00:33:09,334
And it already does wonders in some
例如，它已经在图像处理领域
570
00:33:09,334 --> 00:33:11,936
image processing for example
取得了不错的成绩。
571
00:33:11,936 --> 00:33:15,680
that Bo (Lechnowsky) will show you tomorrow.
Bo (Lechnowsky)会在明天给大家做一个这方面的演示。
572
00:33:15,680 --> 00:33:17,968
Something that the C language doesn't have
下面是C语言本身不具备，
573
00:33:17,968 --> 00:33:22,310
or most very low-level languages don't have:
或者说大多数低级编程语言也都不具备的东西。
574
00:33:22,310 --> 00:33:24,792
Red/System has namespaces,
Red/System有命名空间的概念，
575
00:33:24,792 --> 00:33:27,024
which are something like contexts in Rebol
类似于Rebol里的语境
576
00:33:27,024 --> 00:33:33,586
but very static, so we are using the CONTEXT keyword
但是是静态的，所以我们在Red/System中也用CONTEXT
577
00:33:33,586 --> 00:33:35,909
to declare them in Red&#x2F;System also.
 来声明。
578
00:33:35,909 --> 00:33:38,936
And you can also use the WITH keyword
你还可以使用WITH关键字
579
00:33:38,936 --> 00:33:43,428
to put some part of your code inside a context
将部分代码置于某个语境中，
580
00:33:43,428 --> 00:33:47,121
something like declarations in other languages.
类似于其他编程语言中命名空间的声明。
581
00:33:47,121 --> 00:33:52,155
We have a very limited type system in Red/System
在Red/System中数据类型非常有限，
582
00:33:52,155 --> 00:34:00,763
We have nine types.
共有9种类型，
583
00:34:00,763 --> 00:34:05,467
So basically the same datatypes as C.
基本上与C语言一致。
584
00:34:05,467 --> 00:34:11,372
The function datatype isn't a fully first-class datatype
函数类型并不算是"一等公民"，
585
00:34:11,372 --> 00:34:16,155
I have hesitated a lot about that, because...
我曾对此犹豫再三，因为...
586
00:34:16,155 --> 00:34:19,723
if I make it a fully first-class datatype
如果我将它实现为一个完整意义上的“一等公民”类型的话，
587
00:34:19,723 --> 00:34:22,571
People will start asking for me
可能就会有人要求我
588
00:34:22,571 --> 00:34:24,925
to make Red/System a functional language.
将Red/System设计成一种函数式编程语言。
589
00:34:24,925 --> 00:34:27,986
Which is possible but it's not the goal.
这一点是可以做到的，但是它并不是我们的目标。
590
00:34:27,986 --> 00:34:32,540
It doesn't serve any purpose, so I'm quite reluctant
这样做其实没有什么用途，因此我很不愿意
591
00:34:32,540 --> 00:34:37,835
to add new features on that datatype.
去给这个数据类型添加新功能。
592
00:34:37,835 --> 00:34:40,324
We have type inference,
我们还有类型推断，
593
00:34:40,324 --> 00:34:42,395
so you don't have to specify the data type
不用指定局部变量的数据类型，
594
00:34:42,395 --> 00:34:45,235
for local variables, the compiler will guess it.
编译器会进行推测。
595
00:34:45,235 --> 00:34:48,666
We also have a limited type-casting
兼容的数据类型之间可以进行简单的类型转换，
596
00:34:48,666 --> 00:34:52,473
between compatible data types.
当然也是一个非常有限的功能。
597
00:34:52,473 --> 00:34:56,548
And we have something C doesn't have
我们还有C语言不具备但
598
00:34:56,548 --> 00:35:04,017
but C++ has, which is some level of reflection.
C++具备某种程度的反射机制。
599
00:35:04,017 --> 00:35:07,445
So you can declare some function in Red/System 
你可以在Red/System中声明一个
600
00:35:07,445 --> 00:35:12,157
with a variable number of arguments
参数个数不确定的函数。
601
00:35:12,157 --> 00:35:14,311
you can put brackets around them
可以使用方括号将参数们括起来
602
00:35:14,311 --> 00:35:16,341
and inside the body of that function
然后在函数内部
603
00:35:16,341 --> 00:35:19,854
you can walk through that list of arguments
遍历参数列表，
604
00:35:19,854 --> 00:35:23,665
and you can query the type of each argument.
查询每个参数的类型。
605
00:35:23,665 --> 00:35:26,778
So that's quite a powerful feature,
这是一个相当强大的特征，
606
00:35:26,778 --> 00:35:32,499
and actually Kaj de Vos used it to build
事实上Kaj de Vos已经利用这个功能用Red/System构建了
607
00:35:32,499 --> 00:35:36,773
a VID-like dialect in Red/System
一个与VID类似的方言
608
00:35:36,773 --> 00:35:38,853
which is quite a feat because
这是一项伟大的壮举，因为
609
00:35:38,853 --> 00:35:42,243
we don't have symbols in Red/System :-)
在Red/System语言中并不能进行符号式编程。:-)
610
00:35:42,243 --> 00:35:47,656
So it looks like VID but it's using that feature
这个方言看起来很像VID，但是运行方式采用的是
611
00:35:47,656 --> 00:35:50,854
to run it, and it's really great.
反射机制，真的非常棒。
612
00:35:50,854 --> 00:35:55,630
We also have a preprocessor in Red/System
在Red/System中还有一个预处理器，
613
00:35:55,630 --> 00:36:01,262
but I would like to drop it in the next major release
但是我打算在下一个较大版本发布中将其去除，
614
00:36:01,262 --> 00:36:06,590
because we have more problems with that
因为它给我们带来的麻烦要远大于
615
00:36:06,590 --> 00:36:11,779
than we have advantages.
给我们带来的好处。
616
00:36:11,779 --> 00:36:13,727
So we'll keep a few of them
我们会有选择地保留一部分
617
00:36:13,727 --> 00:36:16,774
but we need to rethink it and redesign it.
但是需要重新规划和设计。
618
00:36:16,774 --> 00:36:20,186
The #define is a very powerful option
#define是一个相当强大的工具，
619
00:36:20,186 --> 00:36:22,128
because it gives you almost the same power
因为它带给你的是与C语言中的宏几乎一样的能力，
620
00:36:22,128 --> 00:36:27,392
as C macros, so you can even use parameters.
你甚至可以向它传递参数。
621
00:36:27,392 --> 00:36:34,001
We also want to have some low-level CPU support
我们还设想要一些能够访问CPU的低层级的功能，
622
00:36:34,001 --> 00:36:39,385
currently we have access to some CPU registers
目前可以跨平台
623
00:36:39,385 --> 00:36:41,747
in a cross-platform way.
访问一些CPU的暂存器。
624
00:36:41,747 --> 00:36:43,617
We have access to the stack --
我们可以访问堆栈（stack）——
625
00:36:43,617 --> 00:36:46,743
you can manipulate the native stack
你可以在Red/System层级跨平台
626
00:36:46,743 --> 00:36:49,724
at the Red/System level in a cross-platform way.
对本地堆栈进行操作。
627
00:36:49,724 --> 00:36:55,232
And we'll add support for interruption I/Os
我们还会添加对I/O中断
628
00:36:55,232 --> 00:37:02,004
and other very basic CPU features.
以及其他CPU基本功能的支持。
629
00:37:02,004 --> 00:37:07,289
Maybe we'll add some inline assembler support
可能还会增加一些对内联汇编的支持
630
00:37:07,289 --> 00:37:10,224
but it's not currently a big need.
但是目前还不是一个要紧的需求。
631
00:37:10,224 --> 00:37:13,926
A few metrics about the Red project.
下面是对Red项目的一些说明。
632
00:37:13,926 --> 00:37:18,596
So it's BSD, for most of the codebase.
大部分代码采用的是BSD协议
633
00:37:18,596 --> 00:37:22,560
And the runtime parts of Red are "BSL"
Red的运行时采用的是“BSL”协议
634
00:37:22,560 --> 00:37:25,945
which is the "Boost Software License"
它的意思是“Boost软件协议”（Boost Software License）
635
00:37:25,945 --> 00:37:32,015
which is even more liberal than BSD.
这个协议比BSD协议还要宽松，
636
00:37:32,015 --> 00:37:34,999
So you have even less restriction than BSD.
限制更少。
637
00:37:34,999 --> 00:37:37,856
We are on GitHub since the beginning
我们从一开始就将代码托管在了Github上，
638
00:37:37,856 --> 00:37:43,033
we have 9 committers... I think that's wrong
我们有9个核心提交者...我想这里有点小差错
639
00:37:43,033 --> 00:37:46,604
it's 11 committers now.
现在应该是11个了。
640
00:37:46,604 --> 00:37:50,335
We have more than 2,000 commits
共计2000多次提交
641
00:37:50,335 --> 00:37:52,867
without counting merge commits.
不包括提交合并。
642
00:37:52,867 --> 00:37:58,035
We have about 500 tickets in the bug tracker
在bug追踪库里有大约500个tickets
643
00:37:58,035 --> 00:38:00,490
but they are almost all closed
大多都已经处于关闭状态了。
644
00:38:00,490 --> 00:38:03,576
we try to get them closed as fast as possible
我们尽可能做到bug一出现就其将解决掉
645
00:38:03,576 --> 00:38:05,852
to avoid piling them up.
以防它们积累起来。
646
00:38:05,852 --> 00:38:07,516
Because once they pile up,
因为一但积累起来，
647
00:38:07,516 --> 00:38:10,788
you almost never get them processed.
就几乎不可能对它们进行处理了。
648
00:38:10,788 --> 00:38:14,469
So we really need to keep that very, very low.
所以非常有必要将它们的数量保持在一个极低的水平。
649
00:38:14,469 --> 00:38:16,696
We have a lot of unit tests
我们还有非常多的单元测试用例
650
00:38:16,696 --> 00:38:19,569
which are built by Peter Wood
这些都是Peter Wood写的
651
00:38:19,569 --> 00:38:23,180
who has done great work on that.
他为此做了相当大的贡献
652
00:38:23,180 --> 00:38:25,361
It's very, very helpful.
帮了我们的大忙。
653
00:38:25,361 --> 00:38:27,897
And here you have a few metrics
下面是关于
654
00:38:27,897 --> 00:38:30,019
about the size of the source code
源代码代码量的统计，
655
00:38:30,019 --> 00:38:32,026
for the Red and Red/System parts.
分别是Red的和Red/System的，
656
00:38:32,026 --> 00:38:34,073
For the compiler, for the linker.
从编译器和链接器两方面考量。
657
00:38:34,073 --> 00:38:35,923
So you can see for yourself
你可以亲眼看到
658
00:38:35,923 --> 00:38:37,897
that's a really small codebase.
这个代码库有多么小。
659
00:38:37,897 --> 00:38:41,619
So you can achieve a lot, thanks to Rebol :-)
多亏有了Rebol，一个人可以取得相当大的成就。
660
00:38:41,619 --> 00:38:45,444
you can achieve a lot with a small codebase
使用一个很小的代码库、聊聊数行代码
661
00:38:45,444 --> 00:38:47,680
and a few lines of code.
就可以取得这么大的成绩。
662
00:38:47,680 --> 00:38:50,946
You can compare that to other toolchains
与其他工具相比较，
663
00:38:50,946 --> 00:38:55,006
and you'll often see one or two
（代码量上）通常会看到一到两个
664
00:38:55,006 --> 00:38:57,700
orders of magnitude of difference.
数量级的差距。
665
00:38:57,700 --> 00:38:59,251
Of course they are probably covering
固然它们的问题覆盖面
666
00:38:59,251 --> 00:39:01,428
more ground than we do.
比我们的要广。
667
00:39:01,428 --> 00:39:06,544
But with such a small codebase
然而我们仅仅使用一个很小的代码库就
668
00:39:06,544 --> 00:39:09,376
we are already covering a lot of ground.
涵盖了相当大的范围。
669
00:39:09,376 --> 00:39:14,352
So we still have a lot of work
我们仍然有很多工作要做，
670
00:39:14,352 --> 00:39:18,824
It's still under heavy construction.
项目仍然处在繁忙的开发中。
671
00:39:18,824 --> 00:39:23,389
So we have some big core parts missing, still.
我们还有几个核心部分尚未开发。
672
00:39:23,389 --> 00:39:30,653
We need object support, which is not yet there.
我们需要支持对象，这部分还没有。
673
00:39:30,653 --> 00:39:34,083
We don't have proper error handling yet
也还没有合适的错误处理机制，
674
00:39:34,083 --> 00:39:36,009
because we need OBJECT! for that.
我们需要OBJECT!类型（即对象）来支持它。
675
00:39:36,009 --> 00:39:40,244
We lack type checking for arguments
在编译器的某些部分
676
00:39:40,244 --> 00:39:42,915
in some parts of the compiler.
还缺乏对参数类型的检查功能。
677
00:39:42,915 --> 00:39:45,487
We don't have the I/O yet, but...
目前我们还不支持I/O，不过
678
00:39:45,487 --> 00:39:50,941
of course objects and I/O are very high on the list
对象和I/O的优先级很高
679
00:39:50,941 --> 00:39:54,697
They probably will be implemented this summer.
大概会在今年夏天开发出来。
680
00:39:54,697 --> 00:39:59,696
We want some level of concurrency support
在1.0版本中我们打算支持一定的并发功能，
681
00:39:59,696 --> 00:40:05,334
in the 1.0, and we naturally also want
自然我们还打算有
682
00:40:05,334 --> 00:40:09,829
a modular compilation and module system.
一个模块化编译系统和一个模块体系。
683
00:40:09,829 --> 00:40:14,260
We will probably provide a very minimal Red IDE
我们可能会提供一个非常小的Red IDE，
684
00:40:14,260 --> 00:40:18,032
which will probably just be a code editor
它可以用作一个编辑器
685
00:40:18,032 --> 00:40:23,468
plus a debugger... and we will work
外加调试器...我们会在以后的版本中
686
00:40:23,468 --> 00:40:27,570
to extend that in future versions.
对它进行扩展。
687
00:40:27,570 --> 00:40:31,050
We also want full documentation
我们要有一份全面的文档，
688
00:40:31,050 --> 00:40:37,597
so that's a big showstopper to release a 1.0
这会是1.0版本发布过程中出彩的一幕。
689
00:40:37,597 --> 00:40:41,836
so we have a lot of work to write that documentation
编写文档和教程
690
00:40:41,836 --> 00:40:43,650
and to write tutorials.
有相当多的工作要做。
691
00:40:43,650 --> 00:40:46,529
And of course, we need to have a new website
当然了，为了准备1.0版本的发布
692
00:40:46,529 --> 00:40:49,753
for the version 1.0 launch.
我们还需要准备一个新的网站。
693
00:40:51,613 --> 00:40:54,761
But that's not all... :-)
但是这还不是全部... :-)
694
00:40:54,761 --> 00:40:57,310
that's not the real Red.
这还不是真正的Red。
695
00:40:57,310 --> 00:41:00,523
The real Red will be the 2.0.
真正地Red将会出现在2.0版本中。
696
00:41:00,523 --> 00:41:05,640
And we have a pretty good cast for that (laughter)
我们有一个相当华丽的阵容（笑声）
697
00:41:05,640 --> 00:41:07,538
So what is "The Real Red"?
那么什么才是“真正的Red”呢？
698
00:41:07,538 --> 00:41:11,329
In fact, what I've presented so far
实际上，到目前为止我所说的
699
00:41:11,329 --> 00:41:13,583
is a kind of scaffolding.
只是一堆建筑材料。
700
00:41:13,583 --> 00:41:15,570
Because the real Red is this one.
因为真正的Red将会是这样的，
701
00:41:15,570 --> 00:41:23,308
The real Red will be basically a JIT compiler
真正地Red基本上就是一个JIT编译器
702
00:41:23,308 --> 00:41:27,206
that will be able to work as a static compiler too.
它也可以用作静态编译器。
703
00:41:27,206 --> 00:41:29,613
The whole internal architecture
整个的内部结构
704
00:41:29,613 --> 00:41:32,929
will be totally different than the current one
将会与目前这个处于自举阶段的版本
705
00:41:32,929 --> 00:41:35,846
implemented in the bootstrapped version.
大不相同。
706
00:41:35,846 --> 00:41:39,254
So it will be plugin-oriented
它是面向插件的，
707
00:41:39,254 --> 00:41:40,910
so basically the compiler and the toolchain
所以编译器和工具链基本上
708
00:41:40,910 --> 00:41:44,718
will be an empty shell -- a framework --
就是一个外壳——或者说一个框架——
709
00:41:44,718 --> 00:41:49,830
where you will be able to plug in some modules
从语法分析到目标文件的生成各个阶段，
710
00:41:49,830 --> 00:41:54,223
to add features at every stage of the compilation.
你都可以为之添加模块
711
00:41:54,223 --> 00:41:57,606
From the parsing to the generation of the files.
来增加新的功能。
712
00:41:57,606 --> 00:42:00,981
You will have an API to work with.
你都会有与之对应的API来做这些事情。
713
00:42:00,981 --> 00:42:03,679
So I will provide the framework
这样我提供的是一个框架
714
00:42:03,679 --> 00:42:07,304
and the minimal modules to make it work
和最少数量的模块，
715
00:42:07,304 --> 00:42:10,946
to have the same level of features as the 1.0.
它们能够提供与1.0版本的相同的功能点。
716
00:42:10,946 --> 00:42:15,920
And such an API will be of course documented
这些API当然会写入文档中，
717
00:42:15,920 --> 00:42:18,986
so anyone will be able to modify
这样的话人人都可以以一种互不影响
718
00:42:18,986 --> 00:42:22,012
and add new features to the compiler
和非常结构化的方式
719
00:42:22,012 --> 00:42:25,657
in a very isolated way, and very structured way.
对编译器做修改和添加新功能。
720
00:42:25,657 --> 00:42:29,935
Such an API could also be called at runtime.
这些API也可以在运行过程中被调用
721
00:42:29,935 --> 00:42:34,584
So I can let you imagine the options and possibilities
所以大家可以想象一下
722
00:42:34,584 --> 00:42:37,270
with modifying the compiler itself and the toolchain
在运行时修改编译器本身和所使用的工具链
723
00:42:37,270 --> 00:42:38,819
at runtime.
将会带来多少可能性。
724
00:42:38,819 --> 00:42:40,186
So it's possible at runtime
在运行过程中修改语言本身
725
00:42:40,186 --> 00:42:43,657
to change the language itself or add new features.
或是添加新的功能是完全可行的。
726
00:42:43,657 --> 00:42:47,107
It may sound totally crazy
这些听起来相当疯狂
727
00:42:47,107 --> 00:42:48,494
but it's something other languages
但是这正是某些正在成长中的语言
728
00:42:48,494 --> 00:42:53,525
which are growing right now
在做的事情，
729
00:42:53,525 --> 00:42:56,184
are doing... for example, the Scala language
比如，
730
00:42:56,184 --> 00:42:57,921
is doing exactly that.
Scala就是这么做的。
731
00:42:57,921 --> 00:43:00,094
And some people from the Scala community
一些来自于Scala社区的人
732
00:43:00,094 --> 00:43:04,242
are using this kind of feature to do wonders in Scala
利用这些功能做出了令人惊叹的东西。
733
00:43:04,242 --> 00:43:07,042
For example, one very smart guy
举个例子，一个非常聪明的哥们
734
00:43:07,042 --> 00:43:13,634
used this API to add parallel support to for loops
使用这个API为循环添加了并行计算支持，
735
00:43:13,634 --> 00:43:18,648
by using the GPGPU for parallelizing that
实现并行计算使用的是GPGPU，
736
00:43:18,648 --> 00:43:23,715
using OpenCL as a low-level layer.
底层使用的是开放计算语言（OpenCL）。
737
00:43:23,715 --> 00:43:27,094
So that's a very powerful feature
所以说这是一个非常强大的特性，
738
00:43:27,094 --> 00:43:31,124
and also it makes the compiler architecture
同时也使得编译器的架构更加健壮，
739
00:43:31,124 --> 00:43:37,405
much more solid and allows people to contribute
也使得人们
740
00:43:37,405 --> 00:43:39,391
in a much easier way
以更加简单
741
00:43:39,391 --> 00:43:42,666
and a much more structured way.
更加架构化的方式贡献代码。
742
00:43:42,666 --> 00:43:45,410
So the implication is that the current codebase
这里的言外之意是当前这个编译器的代码库
743
00:43:45,410 --> 00:43:50,145
of the compiler... so in the Red internal diagram
...位于Red内部结构示意图
744
00:43:50,145 --> 00:43:53,929
it was the right side of the blocks...
的右侧的部分...
745
00:43:53,929 --> 00:43:56,942
The current codebase in Rebol 2
目前这个使用Rebol 2写的代码库
746
00:43:56,942 --> 00:44:00,594
is kind of disposable code.
用完就可以丢弃。
747
00:44:00,594 --> 00:44:04,283
So since the beginning, I wrote it very fast
从一开始我就写得非常快，
748
00:44:04,283 --> 00:44:08,540
thinking that I will dump it quickly
觉得可以在一年之内就可以
749
00:44:08,540 --> 00:44:10,412
in about a year,
堆砌起来，
750
00:44:10,412 --> 00:44:14,035
and be able to recode it in Red rapidly.
之后就可以用Red自身快速地重写一遍。
751
00:44:14,035 --> 00:44:18,069
But we changed a lot of things in the project
但是由于中间我们修改了很多东西，
752
00:44:18,069 --> 00:44:22,374
we adjusted to the evolving environment
为应对环境的变化做了很多调整
753
00:44:22,374 --> 00:44:25,218
so we are not yet there.
因此现在尚未达到预期的目标。
754
00:44:25,218 --> 00:44:29,434
So we will first go 1.0 in the bootstrapped version
所以我们在1.0版本中先发布这个自举的版本
755
00:44:29,434 --> 00:44:32,590
and the 2.0 will be the self-hosted version
而后在2.0版本中再发布使用Red重写后的
756
00:44:32,590 --> 00:44:35,173
with the toolchain recoded in Red.
自托管的版本。
757
00:44:35,173 --> 00:44:41,975
The whole Red runtime part will stay the same
整个Red运行时部分将会保持不变，
758
00:44:41,975 --> 00:44:43,714
because it's coded in Red/System
因为它是用Red/System写的，
759
00:44:43,714 --> 00:44:47,340
so it will survive, and that's a very big codebase.
它会被保留下来，这是一个非常大的代码库。
760
00:44:47,340 --> 00:44:50,087
So the only part that will be recoded
这样的话只有使用Rebol 2写的部分
761
00:44:50,087 --> 00:44:53,342
will be the Rebol 2 codebase, which are
需要被重写，基本上
762
00:44:53,342 --> 00:44:56,511
basically the Red and Red/System compilers.
就是Red和Red/System的编译器部分。
763
00:44:56,511 --> 00:44:59,654
Just a few words about the project organization:
简单介绍一些这个项目的管理结构：
764
00:44:59,654 --> 00:45:05,659
we have two collaborators on GitHub
在GitHub上有两位合作者，
765
00:45:05,659 --> 00:45:10,028
which means there's one admin and two other people
这样就有一个管理员和两个拥有管理员权限的
766
00:45:10,028 --> 00:45:15,747
who have admin rights. So if I get hit by a bus
其他成员。如果我不幸被车撞了，
767
00:45:15,747 --> 00:45:21,832
these two guys could take over the source code
这两名成员就会接管Red代码库中的源代码
768
00:45:21,832 --> 00:45:26,973
in the Red repository and manage it.
并对其进行管理。
769
00:45:26,973 --> 00:45:30,940
We have about 11 contributors to the codebase
从开始到现在我们共有11名贡献者。
770
00:45:30,940 --> 00:45:33,673
since the beginning. We have a mailing list.
我们有一个邮件列表，
771
00:45:33,673 --> 00:45:37,359
We have a Facebook page, an IRC channel
一个Facebook页面，一个IRC频道，
772
00:45:37,359 --> 00:45:42,087
with a nice IRC bot from Andreas
里面有一个出自Andreas之手的非常可爱IRC机器人
773
00:45:42,087 --> 00:45:44,471
for reporting commits.
用来报告代码的提交情况。
774
00:45:44,471 --> 00:45:46,792
And of course we are seeking other people
当然我们也在努力寻找
775
00:45:46,792 --> 00:45:49,389
who are interested in contributing
有兴趣贡献代码
776
00:45:49,389 --> 00:45:52,707
and participating in every way
以及以任何一种方式参与到这个项目中来的同路人
777
00:45:52,707 --> 00:45:54,940
because it's quite a big project...
因为这是一个极其宏大的项目...
778
00:45:54,940 --> 00:45:58,775
and we need a lot of helping hands.
我们需要很多援手。
779
00:46:00,945 --> 00:46:03,564
Last but not least :-)
最后一点，也是非常重要的一点 :-)
780
00:46:03,564 --> 00:46:09,450
I've invested in this project... since I've started
从两年半之前开始，
781
00:46:09,450 --> 00:46:12,146
about 2 years and a half ago...
我已经把我的每一分积蓄
782
00:46:12,146 --> 00:46:16,020
every last cent of savings I had. :-)
都投入到了这个项目当中。 :-)
783
00:46:16,020 --> 00:46:20,434
So I'm really believing totally in the project
因此我对这个项目的成功
784
00:46:20,434 --> 00:46:22,075
and the success of the project.
有着十足的信心。
785
00:46:22,075 --> 00:46:27,231
But I run out of money quite quickly. :-)
但是，很快我就经济拮据了。
786
00:46:27,231 --> 00:46:30,128
Since a year ago, I'm living only on donations
一年以来，我完全依靠
787
00:46:30,128 --> 00:46:33,280
that users and followers are sending to me.
这门语言的使用者和追随者的捐助生活。
788
00:46:33,280 --> 00:46:35,522
So I want to thank them a lot
所以在此我对他们表示诚挚的谢意
789
00:46:35,522 --> 00:46:39,136
because I wouldn't be here without them
因为没有他们我不会走到今天，
790
00:46:39,136 --> 00:46:41,448
and Red wouldn't be at this stage
如果没有人们的支援的话
791
00:46:41,448 --> 00:46:42,987
or probably wouldn't be existing
Red也不会走到现今这个阶段，
792
00:46:42,987 --> 00:46:45,865
if people weren't supporting me.
甚至可能根本就不会存在。
793
00:46:45,865 --> 00:46:49,165
So thanks a lot, and we need to continue
所以真的非常感谢！我们需要继续
794
00:46:49,165 --> 00:46:52,832
to support it to make it a reality.
对它进行支援，使它早日完成。
795
00:46:52,832 --> 00:46:55,053
Thank you all for listening.
谢谢大家！
796
00:46:55,053 --> 00:46:59,053
(applause)
（掌声）
